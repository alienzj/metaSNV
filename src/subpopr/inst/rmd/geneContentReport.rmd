---
title: "MetaSNV2 Gene Content Report"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    number_sections: yes
    smart: no
    toc: yes
    df_print: paged
    toc_float: yes
params:
  corrPcutOff_default:
    value: 0.8
  corrScutOff_default:
    value: 0.6
  speciesID:
    value: null
  statCutoff:
    value: 0.05
  rStatCutoff:
    value: 0.5
  rStatCutoff_strong:
    value: 0.7
  minObs:
    value: 10
  subpopOutDir:
    value: ''
  familyType:
    value: 'family'
  geneFamilyAbundancesFile:
    value: ''
  bamSuffix:
    value: '.bam'
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo=TRUE,
  comment=NA,
  warning=TRUE,
  error=F, # keep running even if error encountered
  message=FALSE,
  rows.print=25)

library(ggplot2,warn.conflicts = FALSE)
library(dplyr,warn.conflicts = FALSE)
library(tidyr,warn.conflicts = FALSE)
library(readr,warn.conflicts = FALSE)
library(ggrepel,warn.conflicts = FALSE)
library(DT,warn.conflicts = FALSE)
library(lemon,warn.conflicts = FALSE)

theme_set(theme_bw())
#knit_print.data.frame <- lemon_print

speciesID <- params$speciesID 
subpopOutDir <- params$subpopOutDir 
corrPcutOff_default <- params$corrPcutOff_default #<- 0.8
corrScutOff_default <- params$corrScutOff_default #<- 0.6
statCutoff <- params$statCutoff #<- 0.05
rStatCutoff <- params$rStatCutoff # 0.5
rStatCutoff_strong <- params$rStatCutoff_strong # 0.7
geneFamilyAbundancesFile <- params$geneFamilyAbundancesFile
minObs <- params$minObs
bamSuffix <- params$bamSuffix
```

# Settings

```{r}
# geneFamilyAbundancesFile <- "/Volumes/KESU/scb2/bork/rossum/subspecies/testingSubpopr/inSilicoMock/mine/smallerTestSet/smallGenomes/01_createData/outputs/geneAbundances.tsv"
# subpopOutDir <- "/Volumes/KESU/scb2/bork/rossum/subspecies/testingSubpopr/inSilicoMock/mine/smallerTestSet/smallGenomes/04_subpopr_nonPack/params.hr5.hs80.ps80/defaults/"
# speciesID <- "refGenome2clus"

# geneFamilyAbundancesFile <- "~/tmp/subpopTest/testingSubpopr/inSilicoMock/mine/smallerTestSet/smallGenomes/01_createData/outputs/geneAbundances.tsv"
# subpopOutDir <- "~/tmp/subpopTest/testingSubpopr/inSilicoMock/mine/smallerTestSet/smallGenomes/04_subpopr/tmp5/params.hr10.hs80.ps80/insilico/"
# speciesID <- "refGenome3clus"

#  geneFamilyAbundancesFile <- "/g/scb2/bork/rossum/metagenomes/human/subspecGeoValidation/all_v3//geneContent/mapToPanGenomes/outputs/counts_unique_norm_sumByNog.tsv"
#  subpopOutDir <- "/g/scb2/bork/rossum/metagenomes/human/subspecGeoValidation/all_v3/subpopr/results_md_s257745/params.hr10.hs80.ps80.gs80//outputs/"
#  speciesID <- "411903"
# bamSuffix	<- ".subspec71.unique.sorted.bam"

do.call(rbind,params) %>% data.frame(stringsAsFactors = F) %>% DT::datatable()
```

# Species: `r as.character(speciesID)`

## Taxonomic classification

```{r}
#accomodate package and non-package
taxaDf <- getSpeciesTaxonomy(speciesID)
if(is.null(taxaDf)){
  print(paste("Taxonomy unknown for ",speciesID))
}
taxaDf
```


# Associations between subspecies and gene families

Based on correlations between the abundances of the within-species clusters and the abundances of gene families

```{r}
pathCorrP <- paste0(subpopOutDir,"/",speciesID,"_corrGenes-pearson.tsv")
pathCorrS <- paste0(subpopOutDir,"/",speciesID,"_corrGenes-spearman.tsv")
if(!file.exists(pathCorrP)){
  stop(paste0("Aborting due to missing file: ",pathCorrP))
  #knitr::knit_exit()
}
if(!file.exists(pathCorrS)){
  print(paste0("Aborting due to missing file: ",pathCorrS))
  #knitr::knit_exit()
}
```

Using files:

```{r}
#cat(c(pathCorrP,pathCorrS))
cat(c(pathCorrP),fill = T)
cat(c(pathCorrS),fill = T)
```


```{r}
corrP <- read_tsv(pathCorrP,col_names = T, col_types = cols(
  geneFamily = col_character(),
  cluster = col_integer(),
  statistic = col_double(),
  #parameter = col_logical(),
  p.value = col_double(),
  estimate = col_double(),
  null.value = col_integer(),
  alternative = col_character(),
  method = col_character(),
  #data.name = col_logical(),
  conf.int = col_logical(),
  conf.int.low = col_double(),
  conf.int.high = col_double(),
  nObs = col_double(),
  q.valueBH = col_double()
)
)
corrS <- read_tsv(pathCorrS,col_names = T, col_types = cols(
  geneFamily = col_character(),
  cluster = col_integer(),
  statistic = col_double(),
  #parameter = col_logical(),
  p.value = col_double(),
  estimate = col_double(),
  null.value = col_integer(),
  alternative = col_character(),
  method = col_character(),
  #data.name = col_logical(),
  nObs = col_double(),
  q.valueBH = col_double()
))

if(!"corrP" %in% ls()){
  print(paste0("Aborting due to error in loading file: ",pathCorrP))
  knitr::knit_exit()
}
if(!"corrS" %in% ls()){
  print(paste0("Aborting due to error in loading file: ",pathCorrS))
  knitr::knit_exit()
}

if( max(corrS$nObs, corrP$nObs) < minObs ){
  print(paste0("Number of observations in correlations (",max(corrS$nObs,max(corrP$nObs)), ") is too small to be meaningful. Aborting report."))
  knitr::knit_exit()
}

```


Number of Pearson correlations tested: `r nrow(corrP)`

Number of significant Pearson correlations (q value < `r statCutoff`):  `r sum(corrP$q.valueBH < statCutoff)`


Number of Spearman correlations tested: `r nrow(corrS)`

Number of significant Spearman correlations (q value < `r statCutoff`): `r sum(corrS$q.valueBH < statCutoff)`


```{r}
corrS$conf.int <- NA
corrS$conf.int.low <- NA
corrS$conf.int.high <- NA
corr <- rbind(corrP,corrS) %>% 
  mutate(statSigLgl = q.valueBH < statCutoff,
         statisticallySignificant = if_else(q.valueBH < statCutoff,true = paste0("q < ",statCutoff),false = paste0("q >= ",statCutoff)),
         cluster = paste0("Subspecies ",cluster),
         cluster=factor(cluster)) %>% 
  rename(correlationR = estimate)
```

# Data distributions

## Distribution of p & q pvalues (uncorrected and corrected)

```{r}
corr %>% 
  select(method, p.value, statisticallySignificant) %>% 
  ggplot(aes(x=p.value,fill=statisticallySignificant))+
  facet_grid(method~.,switch = "y")+
  geom_histogram(position="stack",color="black",binwidth = 0.025)#geom_density(alpha=0.5)
```


## Distribution of correlation R values

```{r}
corr %>% 
  select(method, correlationR, statisticallySignificant) %>% 
  ggplot(aes(x=correlationR,fill=statisticallySignificant))+
    facet_grid(statisticallySignificant~method,switch = "y",margins = "statisticallySignificant") + 
  geom_histogram(binwidth = 0.05)+
  xlim(c(-1,1))+theme(legend.position = "bottom")+
  ylab("Number of gene families")+
  xlab("Strength of correlation (R)")
```

# Comparison of Pearson and Spearman correlation results

```{r test for both cols}
haveBothSP <- all( c("pearson","spearman") %in% unique(as.character(corr$method)) ) 
```

## All results

```{r, eval=!haveBothSP}
print("Results not found for both methods.")
```

Yellow box highlights correlations with high values in both methods

```{r}
corrW <- corr %>% 
  select(geneFamily, cluster, method, correlationR,statSigLgl) %>% 
  spread(key = method,value = correlationR,fill = NA)
x <- sum(is.na(corrW$pearson) | is.na(corrW$spearman))
y <- nrow(corrW)
```

Not plotting `r x` out of `r y` data points due to value not being present for both Pearson and Spearman correlations. 

```{r, eval=haveBothSP}
corrW %>% 
  filter(!is.na(corrW$pearson) & !is.na(corrW$spearman)) %>% 
  ggplot(aes(x=pearson,y=spearman))+
  geom_polygon(data=data.frame(),
               aes(x=c(corrPcutOff_default,corrPcutOff_default,1,1),
                   y=c(corrScutOff_default,1,1,corrScutOff_default)),fill="yellow",alpha=0.25)+
  #geom_hline(yintercept = rStatCutoff)+geom_vline(xintercept = rStatCutoff)+
  geom_hline(yintercept = corrScutOff_default,color="grey80")+
  geom_vline(xintercept = corrPcutOff_default,color="grey80")+
  geom_point(aes(color=cluster,shape=statSigLgl))+
  coord_equal()+ylim(c(NA,1))+xlim(c(NA,1))
```

## Statistically significant results 

```{r}
corrSig <- filter(corr,statSigLgl)
haveBothSP <- all( c("pearson","spearman") %in% unique(as.character(corrSig$method)) ) 
```

```{r, eval=!haveBothSP}
print("Significant results not found for both methods.")
```

```{r, eval=haveBothSP}

df <- corrSig %>% 
  filter(correlationR > rStatCutoff) %>% 
  select(geneFamily, cluster, method, correlationR) %>% 
  spread(key = method,value = correlationR) 

if(ncol(df) == 4 & all(c("pearson","spearman") %in% colnames(df) ) ){ # has spearman and pearson
  dff <- df %>% 
    filter(pearson > corrPcutOff_default, spearman > corrScutOff_default)
  
  p <- dff %>% ggplot(aes(x=pearson,y=spearman,label=geneFamily))+
    geom_point(aes(color=cluster))+
    coord_equal()  
  
  if(nrow(dff)<50){
    p+ggrepel::geom_text_repel()
  }else{
    p
  }
}

```

### Table of results

Values will be NA if not statistically significant: 

```{r, eval=haveBothSP}
sigGeneFamsDF <- corrSig %>% 
  select(geneFamily, cluster, method, correlationR) %>% 
  group_by(geneFamily, cluster) %>% 
  mutate(toOrder = median(correlationR,na.rm = T) ) %>% 
  ungroup() %>% 
  spread(key = method,value = correlationR) %>% 
  filter( (is.na(pearson) | pearson > corrPcutOff_default) &
            (is.na(spearman) | spearman > corrScutOff_default)) %>% 
  arrange(desc(toOrder)) %>% 
  select(-toOrder)

sigGeneFamsDF %>% 
  DT::datatable(filter="top") %>% 
  formatRound(c("pearson","spearman"), digits=3) #%>% formatRound(c("q.valueBH"), digits=4)

```

# Focus on strong subspecies-specific correlations


Here we consider all correlations with: 

- q value < `r statCutoff` for both Spearman and Pearson
- minimum of `r minObs` observations (data points)
- correlation R statistic > `r rStatCutoff_strong` for both Spearman and Pearson
- not correlated with >1 subspecies
- correlation R statistic for other subspecies < `r rStatCutoff` for both Spearman and Pearson

```{r}
corrSubspeciesSpecificGenes <- corr %>% 
  group_by(geneFamily, cluster) %>% 
  summarise(corrPass = all(correlationR > rStatCutoff_strong) & 
           all(nObs >= minObs ) &
           all(statSigLgl),
         corrFail = all(correlationR < rStatCutoff) ) %>% 
  ungroup() %>% 
  group_by(geneFamily) %>% 
  filter(sum(corrPass) == 1 & 
           sum(corrFail) >= 1 ,.preserve = T) %>% # exactly 1 subspecies should pass, all others should fail
  ungroup()
  #filter(statSigLgl & nObs >= minObs & correlationR > rStatCutoff )

corrSubspeciesSpecific <- corr %>% 
  filter(geneFamily %in% corrSubspeciesSpecificGenes$geneFamily) %>% 
  left_join(corrSubspeciesSpecificGenes, by=c("geneFamily","cluster"))
```

```{r}
if(nrow(corrSubspeciesSpecific)==0){
  print("No correlations passed the thresholds. Exiting.")
  knitr::knit_exit()
}
```

## Summary of strong subspecies-specific correlations

```{r}
sigGeneFams <- corrSubspeciesSpecific %>% 
  arrange(-correlationR) %>% 
  pull(geneFamily) %>% unique()
```

Found `r length(sigGeneFams)` correlated gene families.

```{r}
corrSubspeciesSpecificGenes %>% filter(corrPass) %>% count(cluster,name = "Number of specifically and strongly correlated gene families")
```

Distribution of subspecies-specific correlation strengths

```{r}
corrSubspeciesSpecific %>%
  filter(corrPass,.preserve = T) %>% 
  ggplot(aes(x=correlationR))+
    facet_grid(method~cluster,switch = "y") +
  geom_histogram(binwidth = 0.025)+
  #xlim(c( (rStatCutoff-0.1),1.05))+
  ylab("Number of gene families")+
  xlab("Strength of correlation (R)")
```

Table of correlations: 

```{r}
corrSubspeciesSpecific %>% 
  select(geneFamily,cluster,nObs,method,correlationR,conf.int.low,conf.int.high,q.valueBH) %>% 
  mutate(q.valueBH = formatC(q.valueBH, format = "e", digits = 2)) %>% 
  arrange(geneFamily,cluster,method) %>% 
  DT::datatable(filter="top") %>% 
  formatRound(c("correlationR","conf.int.low","conf.int.high"), digits=2) #%>% formatRound(c("q.valueBH"), digits=4)
```


## Example plots of strong subspecies-specific correlations


```{r}
maxToPlot <- 10
tooManyToPlot <- length(sigGeneFams) > maxToPlot

corr %>% filter(geneFamily %in% sigGeneFams) %>%  
  select(geneFamily,cluster,nObs,method,correlationR,conf.int.low,conf.int.high,q.valueBH) %>%
  arrange(cluster) %>% rename(Subspecies = cluster)%>% 
  mutate(q.valueBH = formatC(q.valueBH, format = "e", digits = 2)) %>% 
  DT::datatable(filter="top") %>% 
  formatRound(c("correlationR","conf.int.low","conf.int.high"), digits=2)
```


```{r,warning=F}
# keep top best and bottom worst genes for illustration  
sigGeneFamsTop <- head(sigGeneFams,n = ceiling(maxToPlot/2))
sigGeneFamsBottom <- tail(sigGeneFams,n = floor(maxToPlot/2))
sigGeneFams_maxToPlot <- c(sigGeneFamsTop,sigGeneFamsBottom) %>% 
  unique() # take unique in case length < maxToPlot

## Import gene family abundances
# this can be big, so only import those that we want to plot
f <- function(x,pos){ 
  rename(x, geneFamily = 1) %>% # rename the first column  
  filter(geneFamily %in% sigGeneFams_maxToPlot) 
  }
geneFamilyAbundancesToPlot <- read_tsv_chunked(file = geneFamilyAbundancesFile,
                                 comment = "#",trim_ws = T,col_names = T,
                                 chunk_size = 10000,
                                 callback = DataFrameCallback$new(f)
                                 ) %>% 
  rename(geneFamily = 1) %>% # rename the first column  
  gather(key = sampleID, value = geneFamAbund, -geneFamily)

#geneFamilyAbundancesToPlot <- geneFamilyAbundancesToPlot %>% filter(geneFamily %in% sigGeneFams)
```


```{r}
allClustAbund <- read.table(paste(subpopOutDir,speciesID,'_allClust_relativeAbund.tab',sep=''),sep='\t')
colnames(allClustAbund) <- sub(pattern = "X",replacement = "subspecies",x = colnames(allClustAbund))
allClustAbund$sampleID <- rownames(allClustAbund)
allClustAbund <- allClustAbund %>% gather(key = cluster,value = clustAbund,-sampleID)

corrsToPlot <- merge(x = geneFamilyAbundancesToPlot,allClustAbund, by = "sampleID")
if(nrow(corrsToPlot)==0 &
   "bamSuffix" %in% ls() &
   !is.null(bamSuffix)){
  geneFamilyAbundancesToPlot$sampleID <- paste0(geneFamilyAbundancesToPlot$sampleID,bamSuffix)
  corrsToPlot <- merge(x = geneFamilyAbundancesToPlot,allClustAbund, by = "sampleID")
}

if(nrow(corrsToPlot)==0){
  print("Error in combining the subspecies abundances and the gene family abundances.")
  print(head(geneFamilyAbundancesToPlot))
  print(head(allClustAbund))
  stop("Error in combining the subspecies abundances and the gene family abundances.")
}

plotFamCorr <- function(geneFam) {
  print(geneFam)
  corr %>% filter(geneFamily == geneFam)%>% 
    select(geneFamily, cluster, method, correlationR, q.valueBH, statSigLgl) %>%
    arrange(cluster) %>% rename(Subspecies = cluster) %>%  print()
# 
# corrsToPlot %>% filter(geneFamily == geneFam,.preserve = T) %>% head() %>% print()
# corrsToPlot %>% filter(geneFamily == geneFam,.preserve = T) %>% tail() %>% print()
#   
  p <- corrsToPlot %>% 
    filter(geneFamily == geneFam,.preserve = T) %>%
    # remove samples that don't have any of the clusters
    group_by(sampleID) %>% 
    filter(any(clustAbund != 0)) %>% 
    ggplot(aes(x= geneFamAbund, y=clustAbund)) + 
    geom_point()+
    facet_grid(.~cluster)+
    ggtitle(paste0("Species: ",speciesID,", linear scale\nGene family: ",geneFam))+
    xlab("Abundance of gene family")+
    ylab("Abundance of subspecies")
  print(p)

  print(p+scale_x_log10()+scale_y_log10()+
          ggtitle(paste0("Species: ",speciesID,", log10 scale\nGene family: ",geneFam)))

}
```


```{r,eval=!tooManyToPlot}
if( !tooManyToPlot){
print("Plotting all 'best' correlations")
  tmp <- sapply(sigGeneFams, plotFamCorr)
  rm(tmp)
}
```

```{r,eval=tooManyToPlot, results='asis'}
if(tooManyToPlot){
  cat("### Best correlations")
  print("")
  cat("")
  print(paste0("Too many gene families to plot all of them, only plotting best ",floor(maxToPlot/2),
               " and 'worst' ",ceiling(maxToPlot/2), " (all above quality cutoffs)"))
}
```

```{r,eval=tooManyToPlot}
if(tooManyToPlot){
  tmp <- sapply(sigGeneFamsTop, plotFamCorr)
  rm(tmp)  
}
```


```{r,eval=tooManyToPlot, results='asis'}
if(tooManyToPlot){
  cat("### 'Worst' of the best correlations")
}
```

```{r,eval=tooManyToPlot}
if(tooManyToPlot){
  tmp <- sapply(sigGeneFamsBottom, plotFamCorr)
  rm(tmp)  
}
```
